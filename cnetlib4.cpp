#include "cnetlib4.h"
#include <gcutils/gcutils.h>
#include <functional>

namespace cn {

unsigned g_num_connections = 0;

//Channel stuff

bool NetObject::channel_exists(MSG_UIDTYPE_T cid) {
	for(auto &c : this->channels) {
		if(c->identifier == cid) return true;
	}
	return false;
}

CommunicationChannel* NetObject::find_channel(Connection *c) {
	for(auto &cn : this->channels) {
		if(cn->has_connection(c)) return cn;
	}
	cthrow(ERR_WARN,ERR_RET_NULLPTR);
	return nullptr;
}

CommunicationChannel* NetObject::find_channel(MSG_UIDTYPE_T cid) {
	for(auto &c : this->channels) {
		if(c->identifier == cid) return c;
	}
	cthrow(ERR_WARN,ERR_RET_NULLPTR);
	return nullptr;
}

void Connection::dispatchMessage(NetworkMessage &msg) {
//	gcutils::log(this->getInfo(),": Reconstructed message: ",msg.size);
	if(msg.is_response()) {
		MSG_UIDTYPE_T uid;
		msg >> uid;
		gcutils::print("Calling response callback for ",uid);
		this->call_callback(uid,msg);
		this->trigger_awaken(uid);
		return;
	}

	if(this->owner->hasMessageHandlerFor(msg.type())) {
		this->owner->invoke_handler(this,msg);
	} else {
		this->handleMessage(msg);
	}
	//If no response was provided by the default handler,
	// Send a generic response
	if(msg.needs_response()) {
		auto ack = NetworkMessage(NOTIFY,msg);
		gcutils::print("Sending notify for uid ",msg.uid());
		this->send(ack);
	}
	if(msg.size > 0) cthrow(ERR_WARN,std::to_string(msg.size) + " bytes left unread");
//	free(msg.body);
//	gcutils::log("Done handling");
}

void Connection::handleMessage(NetworkMessage &msg) {
	switch(msg.header.type) {
		case TEXT:
			gcutils::log(this->getInfo(),": ",msg.extract_string(msg.size));
			break;
		case FILE: {
			std::string fn;
			msg >> fn;
			gcutils::log(this->getInfo(),": Got file ",fn,": ",msg.getSize());
			gcutils::export_file(fn,msg.body,msg.size);
			msg.size = 0;
			break;
		}
		case STREAM: {
			std::string fn;
			size_t frag_size;
			msg >> fn;
			msg >> frag_size;
			size_t cur_size = gcutils::file_size(fn);
			gcutils::log(this->getInfo(),": Got stream fragment for ",fn,": ",msg.size," bytes");
			if(frag_size == cur_size)  {
				gcutils::log(this->getInfo(),": File complete, skipping this fragment");
			} else {
				gcutils::append_to_file(fn,msg.body,msg.size);
				msg.size = 0;
			}
//			gcutils::append_to_file(fn,msg.body,msg.size);
			break;
		}
		case REQ_CREATE_CHANNEL: {
			//SERVER
			//Create a new channel on this connection
			this->owner->create_channel(this);
			break;
		}
		case SETID: {
			//CLIENT
			//Set the ID of the client Channel controlled by this connection to the ID generated by the server
			CHAN_IDTYPE_T id;
			msg >> id;
			gcutils::log(this->getInfo(),": Got request to set channel identifier to ",id);
			this->owner->find_channel(this)->identifier = id;
			break;
		}
		case REQ_CONNECTIONS: {
			//CLIENT
			unsigned num;
			msg >> num;
			gcutils::log(this->getInfo(),": Got request to create ",num," new connections");
			if(this->owner->server()) {
				cthrow(ERR_WARN,"Requesting connections from server. Did you mean to do that?");
				break;
			}
			auto this_channel = this->owner->find_channel(this);
			for(int i=0;i<num;i++) {
				auto nc = static_cast<Client*>(this->owner)->connect(this->address);
				this_channel->register_data_connection(nc);
			}
			break;
		}
		case REQ_JOIN_CHANNEL: {
			//SERVER
			CHAN_IDTYPE_T id;
			msg >> id;
			gcutils::log(this->getInfo(),": Got request to join channel ",id);
			auto cc = this->owner->find_channel(id);
			cc->add_data_connection(this);
			break;
		}
		case BLANK:
			cthrow(ERR_WARN,"Received BLANK message");
			break;
		default:
			cthrow(ERR_WARN,"Invalid message type "+std::to_string(msg.header.type));
			break;
	}
}

//================
// Data Writing
//================

//Serialize and send message
void NetWriter::write_header_async(NetworkMessage &msg) {
//	gcutils::log(this->getInfo()+": Writing message: ",msg.getSize());
	asio::async_write(*this->parent->socket,
			  asio::buffer(&msg.header,sizeof(MessageHeader)),
			  std::bind(&NetWriter::write_body_async,this,msg,std::placeholders::_1,std::placeholders::_2)
	);
}

void NetWriter::write_body_async(NetworkMessage &msg,const asio::error_code &err,size_t trans) {
//	gcutils::log("Wrote header: ",trans," bytes");
	asio::async_write(*this->parent->socket,
			  asio::buffer(msg.body,msg.size),
//			  std::bind(ignore,std::placeholders::_1,std::placeholders::_2)
			  std::bind(&NetWriter::await_write,this)
	);
//	this->parent->runAsyncOps();
}

size_t NetWriter::write_header(const NetworkMessage &msg, asio::error_code &ec) {
	return asio::write(*this->parent->socket,asio::buffer(&msg.header,sizeof(MessageHeader)),ec);
}

size_t NetWriter::write_body(const NetworkMessage &msg, asio::error_code &ec) {
	return asio::write(*this->parent->socket,asio::buffer(msg.body,msg.size),ec);
}

size_t NetWriter::send_sync(const NetworkMessage &msg) {
	if(msg.header.type == BLANK) cthrow(ERR_WARN,"Sending blank message. Did you mean to do that?");
	asio::error_code ec;
	size_t	written =	this->write_header(msg,ec);
			written +=	this->write_body(msg,ec);
	return written;
}

void Connection::send_file_with_name(const std::string &path,const std::string &filename) {
	size_t fsize = gcutils::file_size(path);
	if(fsize >= CNET_STREAM_THRESHOLD) {
//		gcutils::log("File larger than 20mb, streaming");
		return this->stream_file_with_name(path,filename);
	}
	std::vector<char> file = gcutils::import_file(path);
	auto msg = NetworkMessage(FILE);
	msg << filename;
	msg.insert_raw((byte_t*)file.data(),file.size());
	this->send_sync(msg);
}

void Connection::stream_file_with_name(const std::string &path, const std::string &filename) {
	byte_t* file_bytes;
	size_t len = gcutils::import_file(path,file_bytes);
	size_t sent = 0;
	while(sent < len) {
		auto msg = NetworkMessage(STREAM);
		msg << filename;
		msg << len;
		size_t sendable = std::min((size_t)CNET_STREAMINFO_LEN,len-sent);
		msg.insert_raw(file_bytes+sent,sendable);
		this->send_sync(msg);
		sent += sendable;
	}
	if(sent > len) cthrow(ERR_WARN,"Sent more bytes than were available");
	free(file_bytes);
}

void Connection::send_str(const std::string &str) {
	auto msg = NetworkMessage(TEXT,(byte_t*)str.data(),str.size());
	this->queued_send(msg);
}

//================
// Transmission
//================

void NetReader::read_header(const asio::error_code &err, size_t transmitted) {
	if(!err) {
		this->stats.log(transmitted);
		MessageHeader h = *(MessageHeader*)(this->netbuf);
		if(h.sig != CNET_HEADER_SIG()) {
			if(h.sig == CNET_HEADER_SIG_UNSIGNED()) {
				gcutils::log(this->getInfo(),": Received unsigned message. Did you forget to sign?");
			} else {
				gcutils::log(this->getInfo(),": Foreign application source, closing connection.");
				this->parent->disconnect();
				return;
			}
		}
		this->init_transfer(h);
	}
	this->start_read();
}

void NetReader::read_body(const asio::error_code &err, size_t transmitted) {
	if(!err) {
		this->stats.log(transmitted);
		this->body.insert_raw(this->netbuf,transmitted);
		if(this->remaining() == 0) {
			auto m = this->getMessage();
			this->parent->dispatchMessage(m);
			this->reset();
		}
	}
	this->start_read();
}

void NetReader::init_transfer(MessageHeader &h) {
	if(h.type == STREAM and h.size > CNET_BUFSIZE_DEFAULT) {
		//Stream fragments don't fit into a single message
		cthrow(ERR_WARN,"Stream fragment will be split between messages, asynchronous single-connection transmission will NOT work");
	}
	this->header = h;
//	gcutils::log(this->getInfo(),": Initializing transfer: ",this->header.getSize());
	this->reading_message = true;
}

std::string NetReader::getInfo() {
	return this->parent->getInfo()+".reader";
}

std::string NetWriter::getInfo() {
	return this->parent->getInfo()+".writer";
}

void NetReader::start_read() {

	//If we are currently reading a message, and the remaining amount of bytes
	// is greater than the buffer size N,
	// read N bytes into the continue_read function
	//
	//Otherwise, if the remaining amount of bytes K will fit in one packet,
	// Read K bytes into the finalize_read function
	//
	//Otherwise, read sizeof(NetworkHeader) bytes into the
	// read_header function.
	//
	//Static assert that sizeof(NetworkHeader) is greater than the network buffer.

	if(this->reading_message) {
		size_t rem = std::min((size_t)CNET_BUFSIZE_DEFAULT,this->remaining());
		asio::async_read(*this->parent->socket,
		asio::mutable_buffer(netbuf,rem),
		std::bind(&NetReader::read_body,this,
				  std::placeholders::_1, //Error code
				  std::placeholders::_2 //Bytes transferred
	 ));
	} else {
		asio::async_read(*this->parent->socket,
			asio::mutable_buffer(netbuf,sizeof(MessageHeader)),
			std::bind(&NetReader::read_header,this,
					  std::placeholders::_1, //Error code
					  std::placeholders::_2 //Bytes transferred
		 ));
	}
}

void Connection::disconnect() {
	this->closeSocket();
	this->owner->disconnect(this);
}

void Connection::closeSocket() {
	this->socket->cancel();
	this->socket->close();
}

std::string Connection::getInfo() {
	return this->owner->getInfo()+".cn"+std::to_string(this->id);
}

Connection::Connection(tcp::socket *_sock,NetObject *_owner): address(_sock->remote_endpoint().address().to_string()), owner(_owner), socket(_sock),id(++g_num_connections),
	net_reader(this),
	net_writer(this) {
	this->net_reader.start_read();
	this->owner->start_io_thread();
}

void NetWriter::queueMessage(NetworkMessage &msg) {
	//	this->write_header(msg);this->parent->runAsyncOps();return;
	//	sync_send(msg);return;
	std::unique_lock<std::mutex> lk1(this->mtx);
	this->messages.push(msg);
	lk1.unlock();
	this->waiter.notify_one();
}

void NetWriter::await_write() {
	//Wait for a message signal
	while(true) {
		std::unique_lock<std::mutex> wlk(this->mtx);
		while(this->messages.empty()) {
			this->waiter.wait(wlk);
		}
		//Dump the message queue
	//	std::unique_lock<std::mutex> wlk(this->mtx);
		NetworkMessage msg = this->messages.front();
		this->messages.pop();
		wlk.unlock();
	//	this->write_header(msg);
	//	this->parent->runAsyncOps();
		this->send_sync(msg);
		free(msg.body);
	}
}

CommunicationChannel *Client::open(std::string address) {
	auto ncc = new CommunicationChannel(this,address);
	if(ncc->valid() == false) {
		cthrow(ERR_WARN,"Failed to connect");
		return nullptr;
	}
	return this->register_channel(ncc);
}

CommunicationChannel *NetObject::create_channel(Connection *control) {
	auto ncc = new CommunicationChannel(this,control);
	this->register_channel(ncc);
	auto req_connections = [ncc,control]() {
		auto m = NetworkMessage(REQ_CONNECTIONS);
		m << ncc->connection_pool.size;
		control->send(m,[ncc]() {
			gcutils::log(ncc->getInfo(),": Handshake complete. Established ",ncc->size()," connections");
		});
	};
	auto msg = NetworkMessage(SETID);
	msg << ncc->identifier;
	control->send(msg,req_connections);
	return ncc;
}

NetObject::NetObject() {
	//Start in a stopped state
	this->io_context.stop();
	this->channel_handler = [this](CommunicationChannel *c) {
		gcutils::log(this->getInfo(),": Channel created from ",c->control->address);
	};
}

CommunicationChannel* NetObject::register_channel(CommunicationChannel *ncc) {
	this->channels.push_back(ncc);
	//Call channel handler...
	this->channel_handler(ncc);
	return ncc;
}



}; // namespace cn
